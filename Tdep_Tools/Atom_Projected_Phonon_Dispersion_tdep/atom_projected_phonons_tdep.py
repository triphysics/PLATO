"""
Atom-Projected Phonon Dispersion Plotter

This Python script reads the phonon dispersion data from a TDEP output file "outfile.dispersion_relations.hdf5"
and plots the atom-projected phonon dispersion using the corresponding eigen vectors.

The main function of this code is to visualize the phonon dispersion of a material 
by plotting its band structure. Additionally, it shows the contribution of each
atom to the phonon modes using the eigen vectors obtained from the "outfile.dispersion_relations.hdf5" file.

Prerequisites:
    1. Ensure that the "outfile.dispersion_relations.hdf5" file is present in the working directory, containing the
       phonon dispersion data as generated by the phonopy package.

Functionality:
    1. Load phonon dispersion data from "outfile.dispersion_relations.hdf5" file.
    2. Extract the eigen vectors representing the atom-projected contributions.
    3. Calculate and normalize the amplitudes of the eigen vectors for visualization.
    4. Plot the atom-projected phonon dispersion for each band and atom using scatter plots.
    5. Add color bar to represent the magnitude of atom contributions.
    6. Set appropriate x-axis labels for k-points using provided labels or empty strings.
    7. Add vertical lines at the k-point positions to indicate distinct Brillouin zones.
    8. Save the generated plot as "proj_phonon.png".

Usage:
    Simply run the script in a directory containing the "outfile.dispersion_relations.hdf5" file to generate the plot.

Note:
    This code assumes that the "outfile.dispersion_relations.hdf5" file contains the required phonon dispersion data
    in the format generated by the phonopy package. Make sure to have the necessary
    dependencies installed before running the script.

Author: Tribhuwan Pandey
"""

import yaml
import numpy as np
import matplotlib.pyplot as plt
import copy
import matplotlib.colors as colors
import matplotlib.cbook as cbook
from matplotlib import cm
import argparse
import h5py
from matplotlib.ticker import FuncFormatter
import matplotlib.ticker as ticker
plt.rcParams['font.family'] = 'Arial'
try:
    from yaml import CLoader as Loader
except ImportError:
    from yaml import Loader

filename="outfile.dispersion_relations.hdf5"

def read_band_hdf5(filename):
    data = h5py.File(filename, "r")
    x = np.array(data["q_values"])
    ys = np.array(data["frequencies"])
    q_ticks = np.array(data["q_ticks"])
    q_ticklabels1 = data.attrs["q_tick_labels"].decode().split()
    num_kpt=len(x)
    num_bnd = data['frequencies'].shape[1]
    #print(num_bnd)
    num_atm = int(num_bnd/3)
    phonon_amplitudes = np.zeros([num_kpt, num_bnd, num_atm])
    normalized_amplitudes = np.zeros([num_kpt, num_bnd, num_atm])
    vec_R=data["eigenvectors_re"]
    vec_I=data["eigenvectors_im"]
    for ikpt in range(num_kpt):
        for nbnd in range(num_bnd):
            vec11=vec_R[ikpt,nbnd, :]
            vec22=vec_I[ikpt,nbnd, :]
            vec_T1 = np.split(vec11, num_atm, axis=0) # plug x,y,z together for each atom
            vec_T2 = np.split(vec22, num_atm, axis=0) # plug x,y,z together for each atom
            for iatm in range(num_atm):
                vec1=vec_T1[iatm]
                vec2=vec_T2[iatm]
                amplitude = (np.sum(vec1 ** 2 + vec2 ** 2))
                phonon_amplitudes[ikpt, nbnd, iatm] = amplitude

    normalized_amplitudes = phonon_amplitudes
    if num_atm==2:
        #print("This is diatomic cell. I will scale intensity between -0.5 and 0.5 for using in cmap plot")
        for iatm in range(num_atm):
            if iatm == 0:
                normalized_amplitudes[:, :, iatm] = normalized_amplitudes[:, :, iatm]/np.max(normalized_amplitudes[:, :, iatm]) * -0.5
            else:
                normalized_amplitudes[:, :, iatm] = normalized_amplitudes[:, :, iatm]/np.max(normalized_amplitudes[:, :, iatm]) * 0.5
    else:
        print("more than 2 atoms are present better use --scatter plot for best results")
        normalized_amplitudes=phonon_amplitudes
 
 # fix the broken path
    q_ticklabels = []

    for label in q_ticklabels1:
        if len(label) > 1:
            # If the string has more than one letter, split it and join with "|"
            modified_label = '|'.join(label)
            q_ticklabels.append(modified_label)
        else:
            q_ticklabels.append(label)

    return x, ys, q_ticks, q_ticklabels, normalized_amplitudes, phonon_amplitudes, num_bnd, num_atm,  num_kpt



def read_atom_names_from_poscar(poscar_file_path):
    try:
        # Initialize a list to store atom names
        atom_names = []

        # Read the POSCAR file
        with open(poscar_file_path, 'r') as file:
            lines = file.readlines()

        # Extract atom names from the lines
        if len(lines) >= 6:  # Check if the file has enough lines
            atom_line = lines[5].split()  # Line containing atom names
            atom_names = atom_line

        return atom_names
    except FileNotFoundError:
        print(f"File '{poscar_file_path}' not found.")
        return []

def plot_cmap_phonon_band(cmap_name, norm, alpha, sf):
    """
    Plot the cmap phonon band structure for a specific atom.

    Parameters:
        cmap_name (str): Name of the color map.
        norm: Color normalization object.
    """

    for ibnd in range(num_bnd):
        plt.scatter(band_distance1, phonon_freq1[:, ibnd],
                    s=sf * abs(normalized_amplitudes_all[:, ibnd]),
                    c=normalized_amplitudes_all[:, ibnd],
                    cmap=cmap_name, alpha=alpha, norm=norm)
        # Additional code for cmap plot goes here...


def plot_scatter_phonon_band(atom_colors, s):

    """
    Plot the projected phonon band structure for a specific atom.

    Parameters:
        atom_index (int): Index of the atom to project (0-indexed).
        color (str): Color of the scatter plot.
        label (str): Label for the scatter plot.
    """
    for ibnd in range(num_bnd):
        for iatm in range(num_atm):
            plt.scatter(band_distance, phonon_freq[:, ibnd],
                    s=s * abs(phonon_amplitudes[:, ibnd, iatm]),
                    c=atom_colors[iatm], alpha=0.2)

def add_legend(atom_labels):
    """
    Plot the legend based on atom labels and colors.

    Parameters:
        atom_labels (list): List of labels for different atoms.
        atom_colors (list): List of colors for different atoms.
    """
    for iatm in range(num_atm):
        plt.scatter([], [], label=atom_labels[iatm], color=atom_colors[iatm])
        plt.legend(loc='best', fontsize=16)
        

def write_data_to_file(output_filename_prefix):
    """
    Write distance, frequency, and normalized amplitude of each atom to separate files.

    Parameters:
        output_filename_prefix (str): The prefix for the output file names.
    """
    for iatm in range(num_atm):
        atom_output_filename = f"{output_filename_prefix}_atom_{iatm}.dat"
        with open(atom_output_filename, 'w') as file:
            # Write header
            file.write("Distance (Angstrom) Frequency (THz) Normalized Amplitude (0-0.5)\n")

            # Write data for each k-point, band, and atom
            for ikpt in range(len(band_distance)):
                for ibnd in range(num_bnd):
                    distance = band_distance[ikpt]
                    frequency = phonon_freq[ikpt, ibnd]
                    amplitude = normalized_amplitudes[ikpt, ibnd, iatm]
                    file.write(f"{distance:.6f} {frequency:.6f} {amplitude:.6f}\n")



band_distance, phonon_freq, x_ticks, x_klabels,normalized_amplitudes, phonon_amplitudes, num_bnd, num_atm,  num_kpt =  read_band_hdf5(filename)

print(x_klabels)

normalized_amplitudes_all =  []
for iatm in range(num_atm):
    normalized_amplitudes_all =np.append(normalized_amplitudes_all, normalized_amplitudes[:,:,iatm])

normalized_amplitudes_all=np.reshape(normalized_amplitudes_all, (num_atm*num_kpt,num_bnd))

band_distance1 = np.tile(band_distance, num_atm)
phonon_freq1 = np.tile(phonon_freq, (num_atm, 1))


atom_colors = ['cyan', 'm', 'red', 'blue', 'green', 'orange', 'purple', 'pink']
norm = cm.colors.Normalize(vmax=np.max(normalized_amplitudes_all[:,:]), vmin=np.min(normalized_amplitudes_all[:,:]))
parser = argparse.ArgumentParser(description="Atom-Projected Phonon Dispersion Plotter")
parser.add_argument("--scatter", action="store_true", help="Use scatter plot mode")
parser.add_argument("--s", default=10, type=float, help="linewidth in colorbar")
parser.add_argument("--sf", default=20, type=float, help="size of symbol in scatter plot")
parser.add_argument("--cmap", default="cool", type=str, help="Use cmap plot mode with specified colormap (default: cool)")
#parser.add_argument("--atom1", default="atom1", type=str, help="Label for the bottom of the color bar (default: atom1)")
#parser.add_argument("--atom2", default="atom2", type=str, help="Label for the top of the color bar (default: atom2)")
parser.add_argument("--gnuplot", action="store_true", help="Write output file")
parser.add_argument("--width", default=6, type=float, help="Width of the figure (default: 6)")
parser.add_argument("--height", default=4, type=float, help="Height of the figure (default: 4)")
parser.add_argument("--ymax", type=float, help="Maximum y-axis limit in THz.")
parser.add_argument("--alpha", default=0.8, type=float, help="transparency level (default: 0.8)")
#parser.add_argument("--mat", type=str, help="name of the material")
parser.add_argument("--ys", type=float, help="shift of title from ymax")
parser.add_argument("--format",default="png", type=str, help="Format of the output file")
args = parser.parse_args()

if args.scatter:
    scatter_mode = True
else:
    scatter_mode = False

# Specify the path to your POSCAR file
poscar_file_path = 'infile.ucposcar'

# Get the atom names from the POSCAR file
atom_names = read_atom_names_from_poscar(poscar_file_path)
material = ''.join(atom_names)

#atom1=atom_names[0]
#atom2=atom_names[1]

# Print the extracted atom names


if scatter_mode:
    # Define colors for different atoms (modify as needed)
    atom_colors = ['cyan', 'm', 'red', 'blue', 'green', 'orange', 'purple', 'pink']
    atom_labels = atom_names
    #[atom_names[0], atom_names[0]]
    output_filename = "Phonon_atom_projected_scatter." + args.format
else:
    atom_colors = None
    output_filename = "Phonon_atom_projected_cmap." + args.format

fig, ax = plt.subplots(figsize=(args.width, args.height))

if not scatter_mode:
    cmap_name = args.cmap
    sf=args.sf
    alpha = args.alpha
    norm = cm.colors.Normalize(vmax=0.5, vmin=-0.5)
    plot_cmap_phonon_band(cmap_name, norm, alpha,sf)
    cbar = plt.colorbar()
    cbar.solids.set(alpha=1)
#    cbar.set_label('Atomic Contribution', rotation=270, labelpad=15, fontsize=18)
    cbar_ticks = [-0.5, 0, 0.5]
    cbar_ticklabels = [atom_names[0], "", atom_names[1]]
    cbar.set_ticks(cbar_ticks)
    cbar.set_ticklabels(cbar_ticklabels)
    cbar.ax.tick_params(labelsize=18)
else:
    s=args.s
    plot_scatter_phonon_band(atom_colors, s)
    add_legend(atom_labels)

if args.gnuplot:
    output_filename_prefix = "atom_projected_phonon_data"
    write_data_to_file(output_filename_prefix)

if args.ymax is not None:
    ax.set_ylim(0, args.ymax)
else:
    ax.set_ylim(0, np.max(phonon_freq)+1)

x_klabels = [w.replace('G','Γ') for w in x_klabels]

#ax.axhline(y=0, color='black', linestyle='--', linewidth=1)  # Zero line
ax.set_ylabel('Frequency (THz)', fontsize=18)
ax.set_xlim(x_ticks[0], x_ticks[-1])

ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=4))
ax.tick_params(axis="x", labelsize=18, direction="in", top=False, length=8, which="major", width=1)
ax.tick_params(axis="x", which='minor', length=4, direction="in", top=False, width=1)
ax.tick_params(axis="y", labelsize=18, direction="in", right=True, length=8, which="major", width=1)
ax.tick_params(axis="y",which='minor', length=4, direction="in", right=True, width=1)

plt.xticks(x_ticks, x_klabels)


for distance in x_ticks[:]:
    plt.axvline(x=distance, ls='--', color='gray', alpha=0.8, lw=0.5)

 
center_x = (x_ticks[-1]) / 2
    
if args.ys is not None:
    plt.text(center_x, args.ymax-args.ys, material, fontsize=18, color='black', ha='center', va='center')
else:
    plt.text(center_x, args.ymax-1.0, material, fontsize=18, color='black', ha='center', va='center')

plt.tight_layout()
plt.savefig(output_filename)
plt.show()
